# This file has been generated by Niv.

# A record, from name to path, of the third-party packages
let
  readJSON = fp: builtins.fromJSON (builtins.readFile fp);
  hasNixpkgsPath = (builtins.tryEval <nixpkgs>).success;
  hasThisAsNixpkgsPath =
    (builtins.tryEval <nixpkgs>).success && <nixpkgs> == ./.;

  # fetchTarball version that is compatible between all the versions of Nix
  builtins_fetchTarball =
      { url, sha256 }@attrs:
      let
        inherit (builtins) lessThan nixVersion fetchTarball;
      in
        if lessThan nixVersion "1.12" then
          fetchTarball { inherit url; }
        else
          fetchTarball attrs;

  # fetchurl version that is compatible between all the versions of Nix
  builtins_fetchurl =
      { url, sha256 }@attrs:
      let
        inherit (builtins) lessThan nixVersion fetchurl;
      in
        if lessThan nixVersion "1.12" then
          fetchurl { inherit url; }
        else
          fetchurl attrs;

  mk =
      { sourcesJson ? ./sources.json,
        useBuiltinFetchers ? true,
        pkgs ?
          let
            sources = readJSON sourcesJson;
            sources_nixpkgs =
              if builtins.hasAttr "nixpkgs" sources
              then sources.nixpkgs
              else abort
              ''
                  nixpkgs is needed, but I cannot find one to use.
                  Please either
                    * specify <nixpkgs> (through -I or NIX_PATH=nixpkgs=...) or
                    * add a package called "nixpkgs" to your sources.json or
                    * use `sources.__configure { pkgs = ... }` or
                    * use `sources.__configure { useBuiltinFetchers = true; }`
              '';
          in
          if hasNixpkgsPath
          then
              if hasThisAsNixpkgsPath
              then import (builtins_fetchTarball { inherit (sources_nixpkgs) url sha256; }) {}
              else import <nixpkgs> {}
          else
              import (builtins_fetchTarball { inherit (sources_nixpkgs) url sha256; }) {}
      }:

    let
      sources = readJSON sourcesJson;

      # A wrapper around pkgs.fetchzip that has inspectable arguments,
      # annoyingly this means we have to specify them
      fetchzip = { url, sha256 }@attrs: pkgs.fetchzip attrs;

      # A wrapper around pkgs.fetchurl that has inspectable arguments,
      # annoyingly this means we have to specify them
      fetchurl = { url, sha256 }@attrs: pkgs.fetchurl attrs;

      mapAttrs = builtins.mapAttrs or
        (f: set: with builtins;
          listToAttrs (map (attr: { name = attr; value = f attr set.${attr}; }) (attrNames set)));

      # borrowed from nixpkgs
      # TODO: get rid of this
      functionArgs = f: f.__functionArgs or (builtins.functionArgs f);
      callFunctionWith = autoArgs: f: args:
        let auto = builtins.intersectAttrs (functionArgs f) autoArgs;
        in f (auto // args);

      getFetcher = spec:
        # TODO:
        # here use
        #   if spec.type == ... then ... else if spec.type == ... etc and
        #   finally abort with error saying "please use __configure { fetcher =
        #   ... }". If `! spec ? type` then abort.
        let fetcherName = spec.type or "builtin-tarball";
        in builtins.getAttr fetcherName {
          "tarball" = if useBuiltinFetchers then builtins_fetchTarball else  fetchzip;
          # TODO: message about deprecation
          "builtin-tarball" = builtins_fetchTarball;
          "file" = if useBuiltinFetchers then builtins_fetchurl else fetchurl;
          "builtin-url" = builtins_fetchurl;
        };

  in
    # NOTE: spec must _not_ have an "outPath" attribute
    (mapAttrs (_: spec:
      if builtins.hasAttr "outPath" spec
      then abort
        "The values in sources.json should not have an 'outPath' attribute"
      else
        if builtins.hasAttr "url" spec && builtins.hasAttr "sha256" spec
        then
          spec //
          { outPath = callFunctionWith spec (getFetcher spec) { }; }
        else spec
        ) sources )//
    { __configure = mk ; };
in
  mk {}
